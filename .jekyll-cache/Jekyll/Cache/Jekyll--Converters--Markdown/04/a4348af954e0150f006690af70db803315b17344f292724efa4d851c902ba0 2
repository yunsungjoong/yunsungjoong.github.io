I""<h2 id="method-메소드란-">Method 메소드란 ?</h2>
<hr />
<p>메소드(method) 또는 멤버 함수(member function)는 객체 지향 프로그래밍에서 객체와 관련된
<u>서브루틴</u>(또는 클래스 내에 존재하는 함수)이며 데이터와 멤버 변수에 대한 접근권한을 갖는다.
JavaScript라는 언어가 가지는 독특한 특징이 있는데, 바로 자바스크립트는 대체로 ‘객체’로 구성되어 있다는 점이다.
함수 또한 자바스크립트 객체로 다루어 지며, 그중에서도 ‘일급객체’ 이므로 값으로 취급 받을 수 있다.
자바스크립트의 객체는 프로퍼티 키와 값으로 구성되어지는데, 이때 값에는 말그대로 JavaScript에서 평가되어지는 모든 값을 담을 수 있다.
함수 또한 그러하다.
이때, 프로퍼티의 값이 함수일때, 이 프로퍼티를 우리는 메소드(method)라 부른다.</p>

<p><b>method를 한글로 번역하면 방법을 의미한다.</b> 개발자가 특정한 행동을 정희하면 그 행동을 호출하면 프로그램에서 
그대로 실행하는 것을 의마한다.</p>

<h3 id="생성자의-기능과-형태">생성자의 기능과 형태</h3>
<hr />
<p>클래스는 초기화를 위해 생성자(<code class="language-plaintext highlighter-rouge">constructor</code>)라는 특별한 코드 블록을 가질 수 있다.
즉, 생성자는 클래스가 <code class="language-plaintext highlighter-rouge">new</code> 표현식에 의해 인스턴스화되어 객체를 생성할 때 
객체의 레퍼런스를 생성하기 전에 객체의 초기화를 위해 사용되는 코드의 블록이다.</p>

<p>개념정리</p>
<ol>
  <li>인스턴스란(Instance) : 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체
 1)개념 :
    <ul>
      <li>객체를 소프트웨어에 실체화 하면 그것을 ‘인스턴스’라고 부른다.</li>
      <li>실체화된 인스턴스는 메모리에 할당된다.</li>
    </ul>
  </li>
</ol>

<p>2)특징 :</p>
<ul>
  <li>인스턴스는 객체에 포함된다고 볼 수 있다.</li>
  <li>oop의 관점에서 객체가 메모리에 할당되어 실제 사용될 때 <code class="language-plaintext highlighter-rouge">인스턴스</code>라고 부른다.</li>
  <li>추상적인 개념(또는 명세)과 구체적인 객체 사이의 관계 에 초점을 맞출 경우에 사용한다.</li>
</ul>

<ol>
  <li>레퍼런스(Reference) : 기본형 변수를 제외한 나머지 타입으로 주기억 장치에 저장되어 객체의 주소값을 가진 변수
 1) 개념 :
    <ul>
      <li>배열 참조 형 : 배열 객체 참조하기 위한 자료 형</li>
      <li>클래스 참조 형 : 클래스 객체를 참조하기 위한 자료 형</li>
      <li>인터페이스 참조 형 : 인터페이스 객체를 참조하기 위한 자료 형</li>
      <li>enum 참조 형 : 열거 형 타입</li>
    </ul>
  </li>
</ol>

<p>2) 특징 :</p>
<ul>
  <li>참조 형은 변수 자체가 값을 포함하지 않으며, 클래스 인스턴스에 대한 참조 값만을 가지고 있다.</li>
  <li>참조 형 변수의 선언은 단지 객체의 위치를 나타내는 메모리만 확보된 상태이므로 각체를 생성하여 그 위치를 참조 형 변수에 할당하여야 한다. (= 인스턴스 생성)</li>
</ul>

<h2 id="메소드-정의">메소드 정의</h2>
<p>클래스에서 메소드를 정의하는 방법은 함수를 정의하는 방법과 크게 다르지 않다.
자바에서 메소드를 정의하는 방법은 다음과 같다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>접근제어자 반환타입 메소드이름 (매개변수목록) { // 선언부
  // 구현부 
}
</code></pre></div></div>
<ol>
  <li>접근 제어자 : 해당 메소드에 접근할 수 있는 범위를 명시한다.</li>
  <li>반환 타입(return type) : 메소드가 모든 작업을 마치고 반환하는 데이터의 타입을 명시한다.</li>
  <li>메소드 이름 : 메소드를 호출하기 위한 이름을 명시한다.</li>
  <li>매개변수 목록(parameters) : 메소드 호출 시에 전달되는 인수의 값을 저장할 변수들을 명시한다.</li>
  <li>구현부 : 메소드의 고유 기능을 수행하는 명령문의 집합</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>예제
class Car { 
  private int currentSpeed;
  private int accelerationTime;
  ...
 (1) public void accelerate(int speed, int second) {// 선언부
    .. 구현부

    System.out.println(second+ '초간 속도를 시속' + speed +'(으)로 가속함!!');
  }
  ....
}
</code></pre></div></div>

<p>위 예제의 1번 라인에서는 accelerate()메소드를 정의하고 있다.
이 메소드 public 접근 제어자를 사용해서 선언되어 한 ㅌ</p>

<h2 id="메소드의-사용-목적">메소드의 사용 목적</h2>
<hr />
<p>클래스에서 메소드를 작성하여 사용하는 이유는 중복되는 코드의 반복적인 프로그래밍을 피할 수 있기 때문이다.
또한, 모듈화로 인해 코드의 가독성도 좋아진다.
그리고 프로그램에 문제가 발생하거나 기능의 변경이 필요할 때도 손쉽게 유지보수를 할 수 있게 된다.
❖ 메소드를 작성할 때는 되도록 하나의 메소드가 하나의 기능만을 수행하도록 작성하는 것이 좋다.</p>

<ol>
  <li>불필요한 중복되어 사용하는 코드를 메소드로 정의하고 호출함으로 가독성을 높일 수 있다.</li>
  <li>코드에 문제 생길 때 문제가 되는 메소드만 수정하면 됨으로 유지보수에 도움이 된다.</li>
</ol>

<h2 id="메소드-만들기">메소드 만들기</h2>
<hr />
<p>객체 안에 메소드를 만들어 보자. 메서드는 객체를 정의할 때 프로퍼티 값으로 
함수를 선언하는 것으로 만들 수 있다.
※ 프로퍼티 : 메소드 간 기능의 중간인 클래스 멤버의 특수한 유형으로 읽기와 쓰기 일반적으로 게터와 세터 메소드 호출로 변환된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const topbig = {
    say: function() {
    	console.log('Hi!?');
    }
};
</code></pre></div></div>
<p>화살표 함수로도 정의할 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const topbig = {
    say: function() {
    	console.log('Hi!?');
    }
};
</code></pre></div></div>

<p>또는 key를 생략하고 function 키워드를 제외한 함수 선언문으로도 메소드를 만들 수도 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const topbig = {
  say() {
    console.log('Hi!?');
  }
};
</code></pre></div></div>

<p>객체를 정의하고 이후에 프로퍼티 값을 추가하는 식으로 만들 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const topbig = {};

topbig.say = function () {
    console.log('Hi!?');
};
</code></pre></div></div>

<p>화살표 함수로는 아래와 같이 만들 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const topbig = {};

topbig.say = () =&gt; {
    console.log('Hi!?');
}
</code></pre></div></div>

<h2 id="메소드-호출">메소드 호출</h2>
<hr />
<p>만들어진 메소드는 객체의 프로퍼티에 접근하고, 그 뒤에 소괄호를 붙여 메소드를 호출할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const topbig = {
    say: function() {
    	console.log('Hi!?');
    }
};

topbig.say(); // Hi!?
</code></pre></div></div>

<p>만약 소괄호를 붙이지 않는다면 메소드를 호출한게 아닌 그냥 메소드에 접근만 한 것이기 때문에 함수를 선언한 내용이 반환된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const topbig = {
    say: function() {
    	console.log('Hi!?');
    }
};

topbig.say; // ƒ () { console.log('Hi!?'); }
</code></pre></div></div>

<p>대괄호 표기법도 마찬가지인데. 대괄호 표기법은 아래 Error로 코멘트 처리한 방식처럼 사용하지 않도록 주의해야 한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const topbig = {
    say: function() {
    	console.log('Hi!?');
    }
};

topbig["say"](); // 
topbig["say"]; // function () { console.log('Hi!?'); }

topbig["say"()]; // Error
topbig[say()]; // Error
</code></pre></div></div>
:ET